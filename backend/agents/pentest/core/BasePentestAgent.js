const { EventEmitter } = require('events');
const fs = require('fs').promises;
const path = require('path');

class BasePentestAgent extends EventEmitter {
    constructor(config = {}) {
        super();
        this.config = config;
        this.results = new Map();
        this.status = 'idle';
        this.startTime = null;
        this.endTime = null;
        this.dataPath = path.join(__dirname, '../../data/pentest');
        this.riskLevels = {
            critical: 4,
            high: 3,
            medium: 2,
            low: 1,
            info: 0
        };
    }

    async initialize(config = {}) {
        this.config = { ...this.config, ...config };
        this.status = 'initialized';
        await this._ensureDataDirectory();
        this.emit('initialized', this.config);
    }

    async _ensureDataDirectory() {
        try {
            await fs.access(this.dataPath);
        } catch {
            await fs.mkdir(this.dataPath, { recursive: true });
        }
    }

    async investigate(target) {
        this.startTime = new Date();
        this.status = 'running';
        this.emit('started', { target, startTime: this.startTime });

        try {
            const results = await this._investigate(target);
            this.results.set(target, results);
            this.status = 'completed';
            this.endTime = new Date();
            this.emit('completed', { target, results, endTime: this.endTime });
            return results;
        } catch (error) {
            this.status = 'error';
            this.emit('error', { target, error });
            throw error;
        }
    }

    async _investigate(target) {
        throw new Error('_investigate method must be implemented by specific agent');
    }

    async generateReport(target, format = 'markdown') {
        const results = this.results.get(target);
        if (!results) {
            throw new Error('No results available for target');
        }

        switch (format.toLowerCase()) {
            case 'markdown':
                return this._generateMarkdownReport(results);
            case 'json':
                return JSON.stringify(results, null, 2);
            case 'maltego':
                return this._generateMaltegoTransform(results);
            default:
                throw new Error(`Unsupported report format: ${format}`);
        }
    }

    async _generateMarkdownReport(results) {
        throw new Error('_generateMarkdownReport method must be implemented by specific agent');
    }

    async _generateMaltegoTransform(results) {
        throw new Error('_generateMaltegoTransform method must be implemented by specific agent');
    }

    async saveResults(target, filename) {
        const results = this.results.get(target);
        if (!results) {
            throw new Error('No results available for target');
        }

        const filePath = path.join(this.dataPath, filename);
        await fs.writeFile(filePath, JSON.stringify(results, null, 2));
        return filePath;
    }

    async loadResults(filename) {
        const filePath = path.join(this.dataPath, filename);
        const data = await fs.readFile(filePath, 'utf8');
        return JSON.parse(data);
    }

    getStatus() {
        return {
            status: this.status,
            startTime: this.startTime,
            endTime: this.endTime,
            resultsCount: this.results.size
        };
    }

    clearResults(target) {
        this.results.delete(target);
    }

    clearAllResults() {
        this.results.clear();
    }

    /**
     * Calculate risk score based on findings
     * @param {Array} findings - Array of findings with risk levels
     */
    calculateRiskScore(findings) {
        if (!findings || !findings.length) return 0;

        const scores = findings.map(finding => this.riskLevels[finding.riskLevel] || 0);
        const totalScore = scores.reduce((sum, score) => sum + score, 0);
        return totalScore / findings.length;
    }

    /**
     * Get risk level based on score
     * @param {number} score - Risk score
     */
    getRiskLevel(score) {
        if (score >= 3.5) return 'critical';
        if (score >= 2.5) return 'high';
        if (score >= 1.5) return 'medium';
        if (score >= 0.5) return 'low';
        return 'info';
    }

    /**
     * Validate target before investigation
     * @param {Object} target - Target to validate
     */
    validateTarget(target) {
        if (!target) {
            throw new Error('Target is required');
        }
        return true;
    }

    /**
     * Format timestamp
     * @param {Date} date - Date to format
     */
    formatTimestamp(date) {
        return date.toISOString();
    }
}

module.exports = BasePentestAgent; 