const BasePentestAgent = require('../../core/BasePentestAgent');
const axios = require('axios');
const dns = require('dns').promises;
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

class SubdomainAgent extends BasePentestAgent {
    constructor(config = {}) {
        super(config);
        this.name = 'SubdomainAgent';
        this.sources = {
            dns: true,
            certificate: true,
            web: true,
            bruteforce: false
        };
    }

    async _investigate(target) {
        this.validateTarget(target);
        
        if (!target.domain) {
            throw new Error('Domain is required for subdomain enumeration');
        }

        const results = {
            domain: target.domain,
            timestamp: this.formatTimestamp(new Date()),
            subdomains: [],
            findings: [],
            statistics: {
                total: 0,
                active: 0,
                withSSL: 0,
                withWebServer: 0
            }
        };

        try {
            // DNS-based enumeration
            if (this.sources.dns) {
                const dnsResults = await this._dnsEnumeration(target.domain);
                results.subdomains.push(...dnsResults);
            }

            // Certificate-based enumeration
            if (this.sources.certificate) {
                const certResults = await this._certificateEnumeration(target.domain);
                results.subdomains.push(...certResults);
            }

            // Web-based enumeration
            if (this.sources.web) {
                const webResults = await this._webEnumeration(target.domain);
                results.subdomains.push(...webResults);
            }

            // Bruteforce enumeration (if enabled)
            if (this.sources.bruteforce) {
                const bruteforceResults = await this._bruteforceEnumeration(target.domain);
                results.subdomains.push(...bruteforceResults);
            }

            // Remove duplicates and validate subdomains
            results.subdomains = this._deduplicateSubdomains(results.subdomains);
            
            // Verify and enrich subdomain information
            results.subdomains = await this._verifySubdomains(results.subdomains);
            
            // Calculate statistics
            results.statistics = this._calculateStatistics(results.subdomains);
            
            // Generate findings
            results.findings = this._generateFindings(results);

            return results;
        } catch (error) {
            throw new Error(`Subdomain enumeration failed: ${error.message}`);
        }
    }

    async _dnsEnumeration(domain) {
        const subdomains = new Set();
        
        try {
            // Try common DNS record types
            const recordTypes = ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'TXT'];
            
            for (const type of recordTypes) {
                try {
                    const records = await dns.resolve(domain, type);
                    if (Array.isArray(records)) {
                        records.forEach(record => {
                            if (typeof record === 'string' && record.includes(domain)) {
                                subdomains.add(record);
                            }
                        });
                    }
                } catch (error) {
                    // Ignore DNS resolution errors for specific record types
                }
            }
        } catch (error) {
            this.emit('warning', { type: 'dns', error: error.message });
        }

        return Array.from(subdomains);
    }

    async _certificateEnumeration(domain) {
        const subdomains = new Set();
        
        try {
            // Use crt.sh API to get certificate information
            const response = await axios.get(`https://crt.sh/?q=${domain}&output=json`);
            const certificates = response.data;

            certificates.forEach(cert => {
                if (cert.name_value) {
                    const names = cert.name_value.split('\n');
                    names.forEach(name => {
                        if (name.includes(domain)) {
                            subdomains.add(name);
                        }
                    });
                }
            });
        } catch (error) {
            this.emit('warning', { type: 'certificate', error: error.message });
        }

        return Array.from(subdomains);
    }

    async _webEnumeration(domain) {
        const subdomains = new Set();
        
        try {
            // Use various web sources for enumeration
            const sources = [
                `https://dns.bufferover.run/dns?q=.${domain}`,
                `https://api.hackertarget.com/hostsearch/?q=${domain}`,
                `https://api.threatminer.org/v2/domain.php?q=${domain}&rt=5`
            ];

            for (const source of sources) {
                try {
                    const response = await axios.get(source);
                    const data = response.data;
                    
                    // Parse response based on source format
                    if (typeof data === 'string') {
                        const lines = data.split('\n');
                        lines.forEach(line => {
                            if (line.includes(domain)) {
                                subdomains.add(line.split(',')[0]);
                            }
                        });
                    } else if (Array.isArray(data)) {
                        data.forEach(item => {
                            if (item.includes(domain)) {
                                subdomains.add(item);
                            }
                        });
                    }
                } catch (error) {
                    // Ignore errors from individual sources
                }
            }
        } catch (error) {
            this.emit('warning', { type: 'web', error: error.message });
        }

        return Array.from(subdomains);
    }

    async _bruteforceEnumeration(domain) {
        const subdomains = new Set();
        
        try {
            // Use sublist3r for bruteforce enumeration
            const command = `sublist3r -d ${domain} -o ${this.dataPath}/sublist3r_${Date.now()}.txt`;
            await execAsync(command);
            
            // Read results
            const results = await fs.readFile(`${this.dataPath}/sublist3r_${Date.now()}.txt`, 'utf8');
            const lines = results.split('\n');
            
            lines.forEach(line => {
                if (line.includes(domain)) {
                    subdomains.add(line.trim());
                }
            });
        } catch (error) {
            this.emit('warning', { type: 'bruteforce', error: error.message });
        }

        return Array.from(subdomains);
    }

    _deduplicateSubdomains(subdomains) {
        return [...new Set(subdomains)].map(subdomain => ({
            name: subdomain,
            verified: false,
            hasSSL: false,
            hasWebServer: false,
            ip: null,
            status: 'unknown'
        }));
    }

    async _verifySubdomains(subdomains) {
        const verifiedSubdomains = [];

        for (const subdomain of subdomains) {
            try {
                // Resolve IP address
                const ip = await dns.resolve(subdomain.name, 'A');
                subdomain.ip = ip[0];
                subdomain.verified = true;

                // Check for SSL
                try {
                    await axios.get(`https://${subdomain.name}`, {
                        validateStatus: () => true
                    });
                    subdomain.hasSSL = true;
                } catch (error) {
                    subdomain.hasSSL = false;
                }

                // Check for web server
                try {
                    await axios.get(`http://${subdomain.name}`, {
                        validateStatus: () => true
                    });
                    subdomain.hasWebServer = true;
                } catch (error) {
                    subdomain.hasWebServer = false;
                }

                verifiedSubdomains.push(subdomain);
            } catch (error) {
                // Skip unverified subdomains
            }
        }

        return verifiedSubdomains;
    }

    _calculateStatistics(subdomains) {
        return {
            total: subdomains.length,
            active: subdomains.filter(s => s.verified).length,
            withSSL: subdomains.filter(s => s.hasSSL).length,
            withWebServer: subdomains.filter(s => s.hasWebServer).length
        };
    }

    _generateFindings(results) {
        const findings = [];

        // Add findings based on statistics
        if (results.statistics.withSSL < results.statistics.total * 0.5) {
            findings.push({
                type: 'security',
                riskLevel: 'medium',
                description: 'Less than 50% of subdomains use SSL/TLS',
                recommendation: 'Enable SSL/TLS for all subdomains'
            });
        }

        if (results.statistics.active < results.statistics.total * 0.3) {
            findings.push({
                type: 'maintenance',
                riskLevel: 'low',
                description: 'Many subdomains appear to be inactive',
                recommendation: 'Review and clean up unused subdomains'
            });
        }

        return findings;
    }

    async _generateMarkdownReport(results) {
        return `# Subdomain Enumeration Report: ${results.domain}

## Enumeration Details
- **Timestamp**: ${results.timestamp}
- **Total Subdomains**: ${results.statistics.total}
- **Active Subdomains**: ${results.statistics.active}
- **SSL Enabled**: ${results.statistics.withSSL}
- **Web Servers**: ${results.statistics.withWebServer}

## Subdomains
${this._formatSubdomains(results.subdomains)}

## Findings
${this._formatFindings(results.findings)}

## Recommendations
${this._generateRecommendations(results)}
`;
    }

    _formatSubdomains(subdomains) {
        if (!subdomains.length) return 'No subdomains found.';

        return subdomains.map(subdomain => `
### ${subdomain.name}
- **IP Address**: ${subdomain.ip || 'Unknown'}
- **Status**: ${subdomain.verified ? 'Active' : 'Inactive'}
- **SSL**: ${subdomain.hasSSL ? 'Yes' : 'No'}
- **Web Server**: ${subdomain.hasWebServer ? 'Yes' : 'No'}
`).join('\n');
    }

    _formatFindings(findings) {
        if (!findings.length) return 'No significant findings.';

        return findings.map(finding => `
### ${finding.type.toUpperCase()} Finding
- **Risk Level**: ${finding.riskLevel}
- **Description**: ${finding.description}
- **Recommendation**: ${finding.recommendation}
`).join('\n');
    }

    _generateRecommendations(results) {
        const recommendations = [];

        // SSL/TLS recommendations
        if (results.statistics.withSSL < results.statistics.total * 0.5) {
            recommendations.push('- Enable SSL/TLS for all subdomains');
            recommendations.push('- Consider using Let\'s Encrypt for free SSL certificates');
        }

        // Maintenance recommendations
        if (results.statistics.active < results.statistics.total * 0.3) {
            recommendations.push('- Review and remove unused subdomains');
            recommendations.push('- Update DNS records to remove stale entries');
        }

        // Security recommendations
        recommendations.push('- Implement proper DNS security measures (DNSSEC)');
        recommendations.push('- Regular monitoring of new subdomain registrations');
        recommendations.push('- Consider using a Web Application Firewall (WAF)');

        return recommendations.join('\n');
    }

    async _generateMaltegoTransform(results) {
        return {
            entities: [
                {
                    type: 'lucie.Domain',
                    value: results.domain,
                    properties: {
                        subdomainCount: results.statistics.total,
                        activeSubdomains: results.statistics.active
                    }
                },
                ...results.subdomains.map(subdomain => ({
                    type: 'lucie.Subdomain',
                    value: subdomain.name,
                    properties: {
                        ip: subdomain.ip,
                        hasSSL: subdomain.hasSSL,
                        hasWebServer: subdomain.hasWebServer,
                        status: subdomain.verified ? 'active' : 'inactive'
                    }
                }))
            ]
        };
    }
}

module.exports = SubdomainAgent; 