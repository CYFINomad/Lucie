const BasePentestAgent = require('../../core/BasePentestAgent');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const path = require('path');
const fs = require('fs').promises;

class NmapAgent extends BasePentestAgent {
    constructor(config = {}) {
        super(config);
        this.name = 'NmapAgent';
        this.nmapPath = config.nmapPath || 'nmap';
        this.scanTypes = {
            quick: '-F -T4',
            normal: '-sV -T4',
            full: '-sV -sC -O -T4',
            vuln: '-sV --script vuln -T4',
            custom: ''
        };
    }

    async _investigate(target) {
        this.validateTarget(target);
        
        const results = {
            target: target.host || target.ip,
            timestamp: this.formatTimestamp(new Date()),
            scanType: target.scanType || 'normal',
            findings: [],
            services: [],
            os: {},
            vulnerabilities: []
        };

        try {
            // Perform the scan
            const scanResults = await this._runNmapScan(target);
            results.findings = this._parseNmapOutput(scanResults);
            
            // Extract services
            results.services = this._extractServices(results.findings);
            
            // Extract OS information
            results.os = this._extractOSInfo(results.findings);
            
            // Extract vulnerabilities
            results.vulnerabilities = this._extractVulnerabilities(results.findings);
            
            // Calculate risk score
            results.riskScore = this.calculateRiskScore(results.vulnerabilities);
            results.riskLevel = this.getRiskLevel(results.riskScore);

            return results;
        } catch (error) {
            throw new Error(`Nmap scan failed: ${error.message}`);
        }
    }

    async _runNmapScan(target) {
        const scanOptions = this.scanTypes[target.scanType] || this.scanTypes.normal;
        const outputFile = path.join(this.dataPath, `nmap_${Date.now()}.xml`);
        
        const command = `${this.nmapPath} ${scanOptions} -oX ${outputFile} ${target.host || target.ip}`;
        
        try {
            await execAsync(command);
            const output = await fs.readFile(outputFile, 'utf8');
            await fs.unlink(outputFile); // Clean up
            return output;
        } catch (error) {
            throw new Error(`Nmap execution failed: ${error.message}`);
        }
    }

    _parseNmapOutput(output) {
        // This is a simplified parser. In a real implementation, you would use a proper XML parser
        const findings = [];
        const lines = output.split('\n');

        for (const line of lines) {
            if (line.includes('<port ')) {
                const port = this._extractPortInfo(line);
                if (port) findings.push(port);
            } else if (line.includes('<osmatch ')) {
                const os = this._extractOSInfo(line);
                if (os) findings.push(os);
            } else if (line.includes('<script ')) {
                const vuln = this._extractVulnerabilityInfo(line);
                if (vuln) findings.push(vuln);
            }
        }

        return findings;
    }

    _extractPortInfo(line) {
        const portMatch = line.match(/portid="(\d+)"/);
        const protocolMatch = line.match(/protocol="(\w+)"/);
        const serviceMatch = line.match(/name="([^"]+)"/);
        const versionMatch = line.match(/product="([^"]+)"/);

        if (portMatch) {
            return {
                type: 'port',
                port: portMatch[1],
                protocol: protocolMatch ? protocolMatch[1] : 'unknown',
                service: serviceMatch ? serviceMatch[1] : 'unknown',
                version: versionMatch ? versionMatch[1] : 'unknown'
            };
        }
        return null;
    }

    _extractOSInfo(line) {
        const nameMatch = line.match(/name="([^"]+)"/);
        const accuracyMatch = line.match(/accuracy="(\d+)"/);

        if (nameMatch) {
            return {
                type: 'os',
                name: nameMatch[1],
                accuracy: accuracyMatch ? parseInt(accuracyMatch[1]) : 0
            };
        }
        return null;
    }

    _extractVulnerabilityInfo(line) {
        const idMatch = line.match(/id="([^"]+)"/);
        const outputMatch = line.match(/<script id="[^"]+" output="([^"]+)"/);

        if (idMatch && outputMatch) {
            return {
                type: 'vulnerability',
                id: idMatch[1],
                output: outputMatch[1],
                riskLevel: this._determineVulnRiskLevel(outputMatch[1])
            };
        }
        return null;
    }

    _determineVulnRiskLevel(output) {
        const outputLower = output.toLowerCase();
        if (outputLower.includes('critical') || outputLower.includes('remote code execution')) {
            return 'critical';
        } else if (outputLower.includes('high') || outputLower.includes('sql injection')) {
            return 'high';
        } else if (outputLower.includes('medium') || outputLower.includes('information disclosure')) {
            return 'medium';
        } else if (outputLower.includes('low') || outputLower.includes('version disclosure')) {
            return 'low';
        }
        return 'info';
    }

    _extractServices(findings) {
        return findings
            .filter(finding => finding.type === 'port')
            .map(port => ({
                port: port.port,
                protocol: port.protocol,
                service: port.service,
                version: port.version
            }));
    }

    _extractOSInfo(findings) {
        const osFindings = findings.filter(finding => finding.type === 'os');
        if (osFindings.length > 0) {
            return osFindings[0];
        }
        return { type: 'os', name: 'unknown', accuracy: 0 };
    }

    _extractVulnerabilities(findings) {
        return findings.filter(finding => finding.type === 'vulnerability');
    }

    async _generateMarkdownReport(results) {
        return `# Nmap Scan Report: ${results.target}

## Scan Information
- **Timestamp**: ${results.timestamp}
- **Scan Type**: ${results.scanType}
- **Risk Level**: ${results.riskLevel}
- **Risk Score**: ${results.riskScore.toFixed(2)}

## Operating System
- **Name**: ${results.os.name}
- **Accuracy**: ${results.os.accuracy}%

## Services
${this._formatServices(results.services)}

## Vulnerabilities
${this._formatVulnerabilities(results.vulnerabilities)}

## Recommendations
${this._generateRecommendations(results)}
`;
    }

    _formatServices(services) {
        if (!services.length) return 'No services detected.';

        return services.map(service => `
### Port ${service.port}/${service.protocol}
- **Service**: ${service.service}
- **Version**: ${service.version || 'Unknown'}
`).join('\n');
    }

    _formatVulnerabilities(vulnerabilities) {
        if (!vulnerabilities.length) return 'No vulnerabilities detected.';

        return vulnerabilities.map(vuln => `
### ${vuln.id}
- **Risk Level**: ${vuln.riskLevel}
- **Details**: ${vuln.output}
`).join('\n');
    }

    _generateRecommendations(results) {
        const recommendations = [];

        // OS-related recommendations
        if (results.os.accuracy < 50) {
            recommendations.push('- Consider running a more detailed OS detection scan');
        }

        // Service-related recommendations
        const outdatedServices = results.services.filter(service => 
            service.version && service.version.includes('old') || 
            service.version && service.version.includes('deprecated')
        );
        if (outdatedServices.length) {
            recommendations.push('- Update outdated services: ' + 
                outdatedServices.map(s => `${s.service} (${s.version})`).join(', '));
        }

        // Vulnerability-related recommendations
        const criticalVulns = results.vulnerabilities.filter(v => v.riskLevel === 'critical');
        if (criticalVulns.length) {
            recommendations.push('- Address critical vulnerabilities immediately');
        }

        return recommendations.length ? recommendations.join('\n') : 'No specific recommendations at this time.';
    }

    async _generateMaltegoTransform(results) {
        return {
            entities: [
                {
                    type: 'lucie.Host',
                    value: results.target,
                    properties: {
                        os: results.os.name,
                        riskLevel: results.riskLevel,
                        riskScore: results.riskScore
                    }
                },
                ...results.services.map(service => ({
                    type: 'lucie.Service',
                    value: `${service.service}:${service.port}`,
                    properties: {
                        port: service.port,
                        protocol: service.protocol,
                        version: service.version
                    }
                })),
                ...results.vulnerabilities.map(vuln => ({
                    type: 'lucie.Vulnerability',
                    value: vuln.id,
                    properties: {
                        riskLevel: vuln.riskLevel,
                        details: vuln.output
                    }
                }))
            ]
        };
    }
}

module.exports = NmapAgent; 